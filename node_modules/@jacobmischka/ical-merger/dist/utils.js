function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import moment from 'moment';
import colorString from 'color-string';
import { isCalendarVisible, getDeepCalendarIdsFromSubGroups } from './server-utils.js';
export function getAliases(config) {
  var aliasMap = new Map(); // $FlowFixMe: https://github.com/facebook/flow/issues/2221

  for (var _i = 0, _Object$entries = Object.entries(config.calendars); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        calendarId = _Object$entries$_i[0],
        calendar = _Object$entries$_i[1];

    if (calendar.aliases) {
      var _iterator = _createForOfIteratorHelper(calendar.aliases),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var alias = _step.value;
          aliasMap.set(alias, calendarId);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  } // $FlowFixMe: https://github.com/facebook/flow/issues/2221


  for (var _i2 = 0, _Object$entries2 = Object.entries(config.calendarGroups); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        calendarGroupId = _Object$entries2$_i[0],
        calendarGroup = _Object$entries2$_i[1];

    if (calendarGroup.aliases) {
      var _iterator2 = _createForOfIteratorHelper(calendarGroup.aliases),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _alias = _step2.value;
          aliasMap.set(_alias, calendarGroupId);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }

  return aliasMap;
}
export function filterHiddenCalendars(config, keys) {
  var isVisible = function isVisible(calendar) {
    return isCalendarVisible(calendar, keys);
  };

  for (var groupId in config.calendarGroups) {
    var group = config.calendarGroups[groupId];
    if (isVisible(group) && group.calendars) group.calendars = group.calendars.filter(function (calendarId) {
      return isVisible(config.calendars[calendarId]);
    });else delete config.calendarGroups[groupId];
  }

  for (var calendarId in config.calendars) {
    var calendar = config.calendars[calendarId];

    if (isVisible(calendar)) {
      if (calendar.subCalendars) calendar.subCalendars = calendar.subCalendars.filter(isVisible);
    } else delete config.calendars[calendarId];
  }

  return config;
}
export function replaceCalendarMacros(config) {
  // $FlowFixMe: https://github.com/facebook/flow/issues/2221
  for (var _i3 = 0, _Object$values = Object.values(config.calendarGroups); _i3 < _Object$values.length; _i3++) {
    var calendarGroup = _Object$values[_i3];
    if (calendarGroup.calendars && Array.isArray(calendarGroup.calendars) && calendarGroup.calendars.length === 1 && calendarGroup.calendars[0] === '<all>') calendarGroup.calendars = Object.keys(config.calendars);
  }

  return config;
}
export function getCalendars(calendarId, allCalendars, allCalendarGroups, customCalendar) {
  var calendar,
      calendars = [],
      eventSources = [],
      calendarMap = {};

  if (calendarId === 'custom') {
    calendar = customCalendar;

    if (customCalendar.calendars) {
      var _eventSources;

      var customCalendars = customCalendar.calendars;
      var actualCalendars = customCalendars.filter(function (id) {
        return id in allCalendars;
      }).map(function (id) {
        return allCalendars[id];
      });

      var _iterator3 = _createForOfIteratorHelper(customCalendars),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _calendarId = _step3.value;
          if (!(_calendarId in calendarMap)) calendarMap[_calendarId] = allCalendars[_calendarId];
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      calendars.push.apply(calendars, _toConsumableArray(actualCalendars));

      (_eventSources = eventSources).push.apply(_eventSources, _toConsumableArray(actualCalendars.map(function (cal) {
        return getSource(cal);
      })));
    }
  } else if (calendarId in allCalendars) {
    calendar = allCalendars[calendarId];

    if (calendar.googleCalendarId || calendar.source) {
      calendars.push(calendar);
      calendarMap[calendarId] = calendar;
      eventSources.push(getSource(calendar));
    }

    if (calendar.subCalendars && Array.isArray(calendar.subCalendars) && calendar.subCalendars.length > 0) {
      var _eventSources2;

      var subCals = calendar.subCalendars;
      calendars.push.apply(calendars, _toConsumableArray(subCals));

      (_eventSources2 = eventSources).push.apply(_eventSources2, _toConsumableArray(subCals.map(function (subCal) {
        return getSource(subCal);
      })));
    }
  } else if (calendarId in allCalendarGroups) {
    calendar = allCalendarGroups[calendarId];

    if (calendar.calendars) {
      var _eventSources3;

      var calIds = calendar.calendars;
      var cals = calIds.map(function (id) {
        return allCalendars[id];
      });
      calendars.push.apply(calendars, _toConsumableArray(cals));

      (_eventSources3 = eventSources).push.apply(_eventSources3, _toConsumableArray(cals.map(function (cal) {
        return getSource(cal);
      })));

      var _iterator4 = _createForOfIteratorHelper(calIds),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var calId = _step4.value;
          if (!(calId in calendarMap)) calendarMap[calId] = allCalendars[calId];
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    } // Add subGroups last


    if (calendar.subGroups) {
      var subGroupIds = calendar.subGroups.filter(function (id) {
        return id in allCalendarGroups && allCalendarGroups[id] !== calendar;
      });
      var subGroups = subGroupIds.map(function (id) {
        return allCalendarGroups[id];
      });

      var _iterator5 = _createForOfIteratorHelper(subGroupIds),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var subGroupId = _step5.value;
          if (!(subGroupId in calendarMap)) calendarMap[subGroupId] = allCalendarGroups[subGroupId];
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      calendars.push.apply(calendars, _toConsumableArray(subGroups));

      var _iterator6 = _createForOfIteratorHelper(subGroups),
          _step6;

      try {
        var _loop = function _loop() {
          var _eventSources4;

          var subGroup = _step6.value;
          var deepCalendarIds = getDeepCalendarIdsFromSubGroups(subGroup, allCalendars, allCalendarGroups);
          deepCalendarIds = Array.from(new Set(deepCalendarIds));
          var deepCalendars = deepCalendarIds.map(function (id) {
            return allCalendars[id];
          });

          (_eventSources4 = eventSources).push.apply(_eventSources4, _toConsumableArray(deepCalendars.map(function (cal) {
            return getSource(cal, subGroup.color);
          })));
        };

        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }

  eventSources = dedupeSources(eventSources);
  return {
    calendar: calendar,
    calendarMap: calendarMap,
    calendars: calendars,
    eventSources: eventSources
  };
}
export function getSource(calendar) {
  var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : calendar.color;
  if (!calendar || !calendar.googleCalendarId && !calendar.source) return {};
  var source = {
    color: color,
    eventDataTransform: function eventDataTransform(eventData) {
      return Object.assign({}, eventData, {
        color: color,
        calendar: calendar
      });
    }
  };

  if (calendar.googleCalendarId && typeof calendar.googleCalendarId === 'string') {
    source.googleCalendarId = calendar.googleCalendarId;
  } else if (calendar.source && typeof calendar.source === 'string') {
    source.url = calendar.source;
  }

  return source;
}

function dedupeSources(sources) {
  // TODO: merge duplicates instead of just using the first one
  var sourceMap = new Map();

  var _iterator7 = _createForOfIteratorHelper(sources),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var source = _step7.value;
      if (source.googleCalendarId && !sourceMap.has(source.googleCalendarId)) sourceMap.set(source.googleCalendarId, source);else if (source.url && !sourceMap.has(source.url)) sourceMap.set(source.url, source);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return Array.from(sourceMap.values());
}

export function nl2br(text) {
  return text.replace(/(?:\r\n|\r|\n)/g, '<br />');
}
export function ucfirst(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
}
export function camelCaseToWords(str) {
  var result = '';

  var _iterator8 = _createForOfIteratorHelper(str),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var char = _step8.value;

      if (result === '') {
        result += char.toUpperCase();
      } else if (char === char.toUpperCase()) {
        result += ' ' + char.toLowerCase();
      } else {
        result += char;
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  return result;
}
export function rgbaOverRgb(rgba) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 255, 255];
  rgba = colorToArray(rgba);
  rgb = colorToArray(rgb);
  if (rgba.length < 4 || rgba[rgba.length - 1] === 1) return colorString.to.rgb(rgba);
  var rgbaAlpha = rgba.pop();
  var resultPieces = [];

  for (var i = 0; i < rgb.length; i++) {
    resultPieces.push(rgb[i] + (rgba[i] - rgb[i]) * rgbaAlpha);
  }

  return colorString.to.rgb(resultPieces);
}

function colorToArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    switch (_typeof(color)) {
      case 'object':
        return color.array();

      case 'string':
        return colorString.get(color).value;
    }
  }

  return [];
}

export function fullCalendarToGoogleUrl(event) {
  var url = 'https://calendar.google.com/calendar/render';
  var params = new URLSearchParams();
  params.set('action', 'TEMPLATE');
  params.set('dates', "".concat(formatCalendarDate(event.start), "/").concat(formatCalendarDate(event.end)));
  params.set('location', event.location);
  params.set('text', event.title);
  params.set('details', event.description);
  return "".concat(url, "?").concat(params.toString());
}
export function fullCalendarToIcs(event) {
  return "BEGIN:VCALENDAR\nVERSION:2.0\nBEGIN:VEVENT\nURL:".concat(event.url, "\nDTSTART:").concat(formatCalendarDate(event.start), "\nDTEND:").concat(formatCalendarDate(event.end), "\nSUMMARY:").concat(event.title, "\nDESCRIPTION:").concat(event.description, "\nLOCATION:").concat(event.location, "\nEND:VEVENT\nEND:VCALENDAR");
}
export function fullCalendarToIcsUrl(event) {
  return encodeURI("data:text/calendar;charset=utf8,".concat(fullCalendarToIcs(event)));
}

function formatCalendarDate(date) {
  return moment(date).toISOString().replace(/-|:|\.\d+/g, '');
}
